{"version":3,"sources":["BinaryHeap.js"],"names":[],"mappings":"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","file":"BinaryHeap-compiled.js","sourcesContent":["export default class BinaryHeap {\n\n  constructor(scoreFunction) {\n    this.content = [];\n    this.scoreFunction = scoreFunction;\n  }\n\n  push(element) {\n    // Add the new element to the end of the array.\n    this.content.push(element);\n    // Allow it to bubble up.\n    this.bubbleUp(this.content.length - 1);\n  }\n\n  pop() {\n    // Store the first element so we can return it later.\n    var result = this.content[0];\n    // Get the element at the end of the array.\n    var end = this.content.pop();\n    // If there are any elements left, put the end element at the\n    // start, and let it sink down.\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.sinkDown(0);\n    }\n    return result;\n  }\n\n  remove(node) {\n    var length = this.content.length;\n    // To remove a value, we must search through the array to find\n    // it.\n    for (var i = 0; i < length; i++) {\n      if (this.content[i] != node) continue;\n      // When it is found, the process seen in 'pop' is repeated\n      // to fill up the hole.\n      var end = this.content.pop();\n      // If the element we popped was the one we needed to remove,\n      // we're done.\n      if (i == length - 1) break;\n      // Otherwise, we replace the removed element with the popped\n      // one, and allow it to float up or sink down as appropriate.\n      this.content[i] = end;\n      this.bubbleUp(i);\n      this.sinkDown(i);\n      break;\n    }\n  }\n\n  size() {\n    return this.content.length;\n  }\n\n  bubbleUp(n) {\n    // Fetch the element that has to be moved.\n    var element = this.content[n], score = this.scoreFunction(element);\n    // When at 0, an element can not go up any further.\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      var parentN = Math.floor((n + 1) / 2) - 1,\n        parent = this.content[parentN];\n      // If the parent has a lesser score, things are in order and we\n      // are done.\n      if (score >= this.scoreFunction(parent))\n        break;\n\n      // Otherwise, swap the parent with the current element and\n      // continue.\n      this.content[parentN] = element;\n      this.content[n] = parent;\n      n = parentN;\n    }\n  }\n\n  sinkDown(n) {\n    // Look up the target element and its score.\n    var length = this.content.length,\n      element = this.content[n],\n      elemScore = this.scoreFunction(element);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      var child2N = (n + 1) * 2, child1N = child2N - 1;\n      // This is used to store the new position of the element,\n      // if any.\n      var swap = null;\n      // If the first child exists (is inside the array)...\n      if (child1N < length) {\n        // Look it up and compute its score.\n        var child1 = this.content[child1N],\n          child1Score = this.scoreFunction(child1);\n        // If the score is less than our element's, we need to swap.\n        if (child1Score < elemScore)\n          swap = child1N;\n      }\n      // Do the same checks for the other child.\n      if (child2N < length) {\n        var child2 = this.content[child2N],\n          child2Score = this.scoreFunction(child2);\n        if (child2Score < (swap == null ? elemScore : child1Score))\n          swap = child2N;\n      }\n\n      // No need to swap further, we are done.\n      if (swap == null) break;\n\n      // Otherwise, swap and continue.\n      this.content[n] = this.content[swap];\n      this.content[swap] = element;\n      n = swap;\n    }\n  }\n}"]}